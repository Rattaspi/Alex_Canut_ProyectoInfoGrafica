#include "Object.hpp"

Object::Object(vec3 scale, vec3 rotation, vec3 position, FigureType typef) {

	GLfloat VertexBufferObject[] = {
		//front
		1.0f ,  1.0f, -1.0f,  0.0f,  0.0f, -1.0f,
		1.0f , -1.0f, -1.0f,  0.0f,  0.0f, -1.0f,
		-1.0f, -1.0f, -1.0f,  0.0f,  0.0f, -1.0f,
		-1.0f, -1.0f, -1.0f,  0.0f,  0.0f, -1.0f,
		-1.0f,  1.0f, -1.0f,  0.0f,  0.0f, -1.0f,
		1.0f ,  1.0f, -1.0f,  0.0f,  0.0f, -1.0f,
		//back
		-1.0f, -1.0f,  1.0f,  0.0f,  0.0f, 1.0f,
		1.0f , -1.0f,  1.0f,  0.0f,  0.0f, 1.0f,
		1.0f ,  1.0f,  1.0f,  0.0f,  0.0f, 1.0f,

		1.0f ,  1.0f,  1.0f,  0.0f,  0.0f, 1.0f,
		-1.0f,  1.0f,  1.0f,  0.0f,  0.0f, 1.0f,
		-1.0f, -1.0f,  1.0f,  0.0f,  0.0f, 1.0f,
		//left
		-1.0f,  1.0f,  1.0f, -1.0f,  0.0f,  0.0f,
		-1.0f,  1.0f, -1.0f, -1.0f,  0.0f,  0.0f,
		-1.0f, -1.0f, -1.0f, -1.0f,  0.0f,  0.0f,
		-1.0f, -1.0f, -1.0f, -1.0f,  0.0f,  0.0f,
		-1.0f, -1.0f,  1.0f, -1.0f,  0.0f,  0.0f,
		-1.0f,  1.0f,  1.0f, -1.0f,  0.0f,  0.0f,
		//right
		1.0f , -1.0f, -1.0f,  1.0f,  0.0f,  0.0f,
		1.0f ,  1.0f, -1.0f,  1.0f,  0.0f,  0.0f,
		1.0f ,  1.0f,  1.0f,  1.0f,  0.0f,  0.0f,

		1.0f ,  1.0f,  1.0f,  1.0f,  0.0f,  0.0f,
		1.0f , -1.0f,  1.0f,  1.0f,  0.0f,  0.0f,
		1.0f , -1.0f, -1.0f,  1.0f,  0.0f,  0.0f,
		//down
		-1.0f, -1.0f, -1.0f,  0.0f, -1.0f,  0.0f,
		1.0f , -1.0f, -1.0f,  0.0f, -1.0f,  0.0f,
		1.0f , -1.0f,  1.0f,  0.0f, -1.0f,  0.0f,
		1.0f , -1.0f,  1.0f,  0.0f, -1.0f,  0.0f,
		-1.0f, -1.0f,  1.0f,  0.0f, -1.0f,  0.0f,
		-1.0f, -1.0f, -1.0f,  0.0f, -1.0f,  0.0f,
		//up
		1.0f ,  1.0f,  1.0f,  0.0f,  1.0f,  0.0f,
		1.0f ,  1.0f, -1.0f,  0.0f,  1.0f,  0.0f,
		-1.0f,  1.0f, -1.0f,  0.0f,  1.0f,  0.0f,
		-1.0f,  1.0f, -1.0f,  0.0f,  1.0f,  0.0f,
		-1.0f,  1.0f,  1.0f,  0.0f,  1.0f,  0.0f,
		1.0f ,  1.0f,  1.0f,  0.0f,  1.0f,  0.0f
	};

	glGenVertexArrays(1, &VAO);
	glBindVertexArray(VAO); {
		glGenBuffers(1, &VBO);
		glBindBuffer(GL_ARRAY_BUFFER, VBO);
		glBufferData(GL_ARRAY_BUFFER, sizeof(VertexBufferObject), VertexBufferObject, GL_STATIC_DRAW);

		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GL_FLOAT), (GLvoid*)0);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GL_FLOAT), (GLvoid*)(3 * sizeof(GL_FLOAT)));

		glBindBuffer(GL_ARRAY_BUFFER, 0);
	}glBindVertexArray(0);

	this->position = position;
	this->scale = scale;
	inc = 1;
	rotX = 0;
	rotY = 0;
}


Object::~Object() {}

void Object::Update(GLFWwindow* window) {
	if (!start) {
		lastFrame = glfwGetTime();
		start = true;
	}

	//delta time
	float dt = glfwGetTime() - lastFrame;
	lastFrame = glfwGetTime();

	//translacion
	bool up = glfwGetKey(window, GLFW_KEY_UP);
	bool down = glfwGetKey(window, GLFW_KEY_DOWN);
	bool right = glfwGetKey(window, GLFW_KEY_RIGHT);
	bool left = glfwGetKey(window, GLFW_KEY_LEFT);
	//movimiento de translacion
	if (up) {
		position.y += inc*dt;
	}
	else if (down) {
		position.y -= inc*dt;
	}
	if (right) {
		position.x += inc*dt;
	}
	else if (left) {
		position.x -= inc*dt;
	}

	//rotacion
	bool rotXPlus = glfwGetKey(window, GLFW_KEY_KP_2);
	bool rotXMin = glfwGetKey(window, GLFW_KEY_KP_8);
	bool rotYPlus = glfwGetKey(window, GLFW_KEY_KP_6);
	bool rotYMin = glfwGetKey(window, GLFW_KEY_KP_4);
	//movimiento rotacion
	if (rotXPlus) {
		rotX += inc * 15 * dt;
	}
	else if (rotXMin) {
		rotX -= inc * 15 * dt;
	}
	if (rotYPlus) {
		rotY += inc * 15 * dt;
	}
	else if (rotYMin) {
		rotY -= inc * 15 * dt;
	}
	


}

void Object::Draw() {
	glBindVertexArray(VAO);
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	glDrawArrays(GL_TRIANGLES, 0, 36);
	glBindVertexArray(0);
}
void Object::Move(vec3 translation) {
	position += translation;
}
void Object::Rotate(vec3 rota) {
	rotation += rota;
}
void Object::Scale(vec3 scal) {
	scale += scal;
}

mat4 Object::GetModelMatrix() {
	mat4 model;
	model = translate(model, position);
	model = rotate(model, radians(rotX), vec3(1, 0, 0));
	model = rotate(model, radians(rotY), vec3(0, 1, 0));
	model = glm::scale(model, scale);
	return model;
}

vec3 Object::GetPosition() {
	return position;
}

void Object::Delete() {
	glDeleteVertexArrays(1, &VAO);
	glDeleteBuffers(1, &VBO);
}